{# THIS File is not automatically generated:
the below applies to the result of this template
#}// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borrowed mode, and only
//! this mode has all AST accessors.

use crate::{
    ast::{self, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode,
};

{% for node, methods in ast %}// {{ node }}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct {{ node }} {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for {{ node }} {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind,
            {%- if methods.enum %}
            {% for kind in methods.enum %} {%  if loop.index > 1 %}| {% endif %}{{ kind | SCREAM }} {%- endfor -%}
            {% else %}
            {{ node | SCREAM }}
            {%- endif %}
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some({{ node }} { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

{%- if methods.enum %}
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum {{ node }}Kind {
{%- for kind in methods.enum %}
    {{ kind }}({{ kind }}),
{%- endfor %}
}

{%- for kind in methods.enum %}
impl From<{{ kind }}> for {{ node }} {
    fn from(n: {{ kind }}) -> {{ node }} {
        {{ node }} { syntax: n.syntax }
    }
}
{%- endfor %}

impl {{ node }} {
    pub fn kind(&self) -> {{ node }}Kind {
        match self.syntax.kind() {
            {%- for kind in methods.enum %}
            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(self.syntax.clone()).unwrap()),
            {%- endfor %}
            _ => unreachable!(),
        }
    }
}

{% endif %}
{% if methods.traits -%}

{%- for t in methods.traits -%}
impl ast::{{ t }} for {{ node }} {}
{% endfor -%}

{%- endif -%}

impl {{ node }} {
{%- if methods.collections -%}
{%- for m in methods.collections -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
    pub fn {{ method_name }}(&self) -> impl Iterator<Item = {{ ChildName }}> {
        super::children(self)
    }
{% endfor -%}
{%- endif -%}

{%- if methods.options -%}
{%- for m in methods.options -%}

{%- if m is string -%}
{%- set method_name = m | snake -%}
{%- set ChildName = m %}
{%- else -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
{%- endif %}
    pub fn {{ method_name }}(&self) -> Option<{{ ChildName }}> {
        super::child_opt(self)
    }
{% endfor -%}
{%- endif -%}
}

{% endfor %}
