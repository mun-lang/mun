{# THIS File is not automatically generated:
the below applies to the result of this template
#}#![cfg_attr(rustfmt, rustfmt_skip)]
// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

#![allow(bad_style, missing_docs, unreachable_pub, clippy::enum_glob_use, clippy::manual_non_exhaustive, clippy::upper_case_acronyms)]
use super::SyntaxInfo;

/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
#[non_exhaustive]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,

{%- for t in concat(a=single_char_tokens, b=multi_char_tokens) %}
    {{t.1}},
{%- endfor -%}
{% for kw in keywords %}
    {{kw | upper}}_KW,
{%- endfor -%}
{% for t in concat(a=literals, b=tokens, c=nodes) %}
    {{t}},
{%- endfor %}
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;

#[macro_export]
macro_rules! T {
{%- for t in concat(a=single_char_tokens, b=multi_char_tokens) %}
    {%- if t.0 == '{' or t.0 == '}' or t.0 == '[' or t.0 == ']' or t.0 == '(' or t.0 == ')' %}
    ('{{t.0}}') => {
        $crate::SyntaxKind::{{t.1}}
    };
    {%- else %}
    ({{t.0}}) => {
        $crate::SyntaxKind::{{t.1}}
    };
    {%- endif %}
{%- endfor -%}
{% for kw in keywords %}
    ({{kw}}) => {
        $crate::SyntaxKind::{{kw | upper}}_KW
    };
{%- endfor %}
}

impl From<u16> for SyntaxKind {
    fn from(d: u16) -> SyntaxKind {
        assert!(d <= (__LAST as u16));
        unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
    }
}

impl From<SyntaxKind> for u16 {
    fn from(k: SyntaxKind) -> u16 {
        k as u16
    }
}

impl SyntaxKind {
    #[rustfmt::skip]
    pub fn is_keyword(self) -> bool {
        matches!(self,
{%- for kw in keywords %}
        {%  if loop.index > 1 %}| {% endif %}{{kw | upper}}_KW
{%- endfor %}
        )
    }

    #[rustfmt::skip]
    pub fn is_symbol(self) -> bool {
        matches!(self,
    {%- for t in concat(a=single_char_tokens, b=multi_char_tokens) %}
        {%  if loop.index > 1 %}| {% endif %}{{t.1}}
    {%- endfor %}
        )
    }

    #[rustfmt::skip]
    pub fn is_literal(self) -> bool {
        matches!(self,
    {%- for t in literals %}
            {%  if loop.index > 1 %}| {% endif %}{{t}}
    {%- endfor %}
        )
    }

    #[rustfmt::skip]
    pub(crate) fn info(self) -> &'static SyntaxInfo {
        match self {
    {%- for t in concat(a=single_char_tokens, b=multi_char_tokens) %}
            {{t.1}} => &SyntaxInfo { name: "{{t.1}}" },
    {%- endfor -%}
    {% for kw in keywords %}
            {{kw | upper}}_KW => &SyntaxInfo { name: "{{kw | upper}}_KW" },
    {%- endfor -%}
    {% for t in concat(a=literals, b=tokens, c=nodes) %}
            {{t}} => &SyntaxInfo { name: "{{t}}" },
    {%- endfor %}
            TOMBSTONE => &SyntaxInfo { name: "TOMBSTONE" },
            EOF => &SyntaxInfo { name: "EOF" },
            __LAST => &SyntaxInfo { name: "__LAST" },
        }
    }

    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
    {%- for kw in keywords %}
            "{{kw}}" => {{kw | upper}}_KW,
    {%- endfor %}
            _ => return None,
        };
        Some(kw)
    }

    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
    {%- for t in single_char_tokens %}
            '{{t.0}}' => {{t.1}},
    {%- endfor %}
            _ => return None,
        };
        Some(tok)
    }
}



