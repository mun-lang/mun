/* automatically generated by rust-bindgen */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
use crate::Privacy;

#[doc = " Represents a globally unique identifier (GUID)."]
#[doc = ""]
#[doc = " GUIDs are generated by taking the MD5 hash of a type's name."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Copy\" derive=\"Debug\" derive=\"PartialEq\"></div>"]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Guid {
    #[doc = " 16-byte MD5 hash"]
    pub b: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_Guid() {
    assert_eq!(
        ::std::mem::size_of::<Guid>(),
        16usize,
        concat!("Size of: ", stringify!(Guid))
    );
    assert_eq!(
        ::std::mem::align_of::<Guid>(),
        1usize,
        concat!("Alignment of ", stringify!(Guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Guid>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Guid), "::", stringify!(b))
    );
}
#[doc = " Represents the type declaration for a value type."]
#[doc = ""]
#[doc = " TODO: add support for structs, polymorphism, enumerations, type parameters, generic type definitions, and constructed generic types."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct TypeInfo {
    #[doc = " Type GUID"]
    pub guid: Guid,
    #[doc = " Type name"]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<TypeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(TypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<TypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " Represents a function signature."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionSignature {
    #[doc = " Function name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Argument types"]
    pub arg_types: *const TypeInfo,
    #[doc = " Optional return type"]
    pub return_type: *const TypeInfo,
    #[doc = " Number of argument types"]
    pub num_arg_types: u16,
    #[doc = " Function accessibility level"]
    pub privacy: Privacy,
}
#[test]
fn bindgen_test_layout_FunctionSignature() {
    assert_eq!(
        ::std::mem::size_of::<FunctionSignature>(),
        32usize,
        concat!("Size of: ", stringify!(FunctionSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).arg_types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(arg_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).return_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).num_arg_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(num_arg_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).privacy as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(privacy)
        )
    );
}
#[doc = " Represents a function declaration."]
#[doc = ""]
#[doc = " `fn_ptr` can be used to call the declared function."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionInfo {
    #[doc = " Function signature"]
    pub signature: FunctionSignature,
    #[doc = " Function pointer"]
    pub fn_ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FunctionInfo() {
    assert_eq!(
        ::std::mem::size_of::<FunctionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(FunctionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionInfo>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionInfo>())).fn_ptr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionInfo),
            "::",
            stringify!(fn_ptr)
        )
    );
}
#[doc = " Represents a module declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct ModuleInfo {
    #[doc = " Module path"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Module functions"]
    pub functions: *const FunctionInfo,
    #[doc = " Number of module functions"]
    pub num_functions: u32,
}
#[test]
fn bindgen_test_layout_ModuleInfo() {
    assert_eq!(
        ::std::mem::size_of::<ModuleInfo>(),
        24usize,
        concat!("Size of: ", stringify!(ModuleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).functions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).num_functions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(num_functions)
        )
    );
}
#[doc = " Represents a function dispatch table. This is used for runtime linking."]
#[doc = ""]
#[doc = " Function signatures and pointers are stored separately for cache efficiency."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct DispatchTable {
    #[doc = " Function signatures"]
    pub signatures: *const FunctionSignature,
    #[doc = " Function pointers"]
    pub fn_ptrs: *mut *const ::std::os::raw::c_void,
    #[doc = " Number of functions"]
    pub num_entries: u32,
}
#[test]
fn bindgen_test_layout_DispatchTable() {
    assert_eq!(
        ::std::mem::size_of::<DispatchTable>(),
        24usize,
        concat!("Size of: ", stringify!(DispatchTable))
    );
    assert_eq!(
        ::std::mem::align_of::<DispatchTable>(),
        8usize,
        concat!("Alignment of ", stringify!(DispatchTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).signatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(signatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).fn_ptrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(fn_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).num_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(num_entries)
        )
    );
}
#[doc = " Represents an assembly declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct AssemblyInfo {
    #[doc = " Symbols of the top-level module"]
    pub symbols: ModuleInfo,
    #[doc = " Dispatch table"]
    pub dispatch_table: DispatchTable,
    #[doc = " Paths to assembly dependencies"]
    pub dependencies: *const *const ::std::os::raw::c_char,
    #[doc = " Number of dependencies"]
    pub num_dependencies: u32,
}
#[test]
fn bindgen_test_layout_AssemblyInfo() {
    assert_eq!(
        ::std::mem::size_of::<AssemblyInfo>(),
        64usize,
        concat!("Size of: ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AssemblyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).symbols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(symbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dispatch_table as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dispatch_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dependencies as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dependencies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).num_dependencies as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(num_dependencies)
        )
    );
}
